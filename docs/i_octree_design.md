# i-Octree 設計ドキュメント

## 概要

i-Octree (incremental Octree) は、通常の Octree 構造を拡張し、リアルタイムでの点群更新・削除・探索を効率的に行うために設計された動的データ構造です。主な用途は、ロボティクスや LiDAR ベースの SLAM（同時自己位置推定・地図構築）など、時間的に変化する 3 次元環境の処理です。

---

## 設計目的

| 目的 | 説明 |
| --- | --- |
| 高速近傍探索 | k-Nearest Neighbor (kNN) および半径探索をリアルタイムに処理 |
| 動的更新 | 点群の追加（insert）・削除（delete）・領域単位削除（box-wise delete）に対応 |
| メモリ効率化 | 連続メモリ格納によるキャッシュ効率の向上と軽量化 |
| 再構築不要 | 木全体を再構築せず、部分的な更新のみで維持可能 |

---

## コア設計要素

### 1. Local Spatially Continuous Storing Strategy

各葉ノード（leaf octant）内の点群を連続メモリ領域に格納する方式。これにより次の効果が得られます。

- 同一葉内の点群アクセスがキャッシュ効率化。
- 探索処理（半径探索・kNN 探索）が高速化。
- メモリ断片化を低減。

構築時に空間局所性を考慮して点群を並び替え、葉ノード単位で連続ブロックを割り当てます。

**Leaf Node Memory Layout**

```
[x₁, y₁, z₁][x₂, y₂, z₂]...[xₙ, yₙ, zₙ]
```

---

### 2. Dynamic Node Construction & Local Updates

i-Octree は動的な構築と局所的な更新を統合しています。

- **挿入 (Insertion)**: 点 \(p\) を該当ノードに挿入し、容量上限 (`max_points_per_leaf`) を超えた場合にのみ分割（subdivide）。分割時にはブロック内の点を再配置し、8 つの子ノードに再分配します。
- **削除 (Deletion / Box-wise Delete)**: 単一点削除は葉ノード内の連続ブロックから対象点を除去し、範囲削除は削除領域が完全にオクタントを覆う場合にノードごと削除します。空ノードは自動的に破棄してメモリを再利用します。
- **範囲外挿入**: 新しい点が現ルートの範囲外に出た場合、新しいルートノードを生成し、既存ツリーを子として再配置します。

---

### 3. Lightweight Node Allocation

- 点が存在しないサブオクタント（空領域）に対してノードを生成しない。
- 木のサイズとメモリ使用量を削減。
- 通常の Octree に比べて最大 30〜60% のメモリ削減を実現。

---

### 4. 局所再配置 (Local Reallocation)

ノード構造や点群の並び替えは局所的に行われます。

| トリガー | 再配置範囲 |
| --- | --- |
| 葉ノードの分割 | 該当ノード内のみ |
| 葉ノード容量超過 | 該当ノード内のみ |
| ノード削除 | 該当ノードのみ |

全体再構築は不要で、\(O(\log N)\) 程度のコストで安定した更新が可能です。

---

## 内部構造

### ノード構造体 (Node)

```cpp
struct Node {
    BoundingBox bbox;               // 空間領域
    std::vector<Node*> children;    // 子ノード（最大8個）
    std::vector<Point> points;      // 連続格納された点群
    bool is_leaf;                   // 葉ノード判定
};
```

### 木全体構造 (iOctree)

```cpp
class iOctree {
public:
    Node* root;
    int max_points_per_leaf;

    void insert(Point p);
    void remove(Point p);
    void delete_box(BoundingBox region);
    std::vector<Point> radius_search(Point p, float r);
    std::vector<Point> knn_search(Point p, int k);
};
```

---

## 探索アルゴリズム

### 近傍探索 (Radius / kNN)

1. 対象点 \(p\) を含む葉ノードを探索。
2. 対象ノードおよび隣接ノードの点をスキャン。
3. 連続格納されたブロックから高速アクセス。
4. 距離計算を行い、条件を満たす点を抽出。

葉レベルでの連続メモリにより、ループ展開・キャッシュヒットが高確率で発生するため、従来 Octree より約 20〜60% 高速化が報告されています。

---

## 特徴比較

| 項目 | 通常 Octree | i-Octree |
| --- | --- | --- |
| データ構築 | 静的構築 | 動的・逐次更新可能 |
| メモリ配置 | 非連続 | 葉ノード単位で連続配置 |
| 挿入・削除 | 再構築が必要 | 局所更新のみ |
| 空領域処理 | 全子ノード生成 | 必要ノードのみ生成 |
| キャッシュ効率 | 低 | 高（局所性最適化） |
| 対応用途 | 静的 3D モデル | 動的 SLAM、LiDAR、リアルタイム地図 |

---

## まとめ

i-Octree は、

- 空間局所性に基づいた連続メモリ構造、
- 局所的な動的更新戦略、
- 軽量ノード設計

によって、リアルタイム 3D 点群処理に最適化された新しい Octree 実装です。特に、頻繁な挿入・削除を伴う動的環境では、従来の Octree より大幅に高速かつ安定した動作を実現します。
